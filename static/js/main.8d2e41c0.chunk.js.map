{"version":3,"sources":["utils.js","components/Lines.js","hooks/index.js","Pages/Home.js","Pages/About.js","App.js","reportWebVitals.js","index.js"],"names":["pathToString","pathData","index","spaceBetweenLines","waveInterval","waveHeights","spacer","getRandomWave","svgWidth","wave","getWaveIntervals","getWaveHeight","waves","i","getOneWaveInterval","waveIntervalIndex","Math","round","random","console","log","getNextStep","targetWave","setTargetWave","length","j","Lines","useState","wavePaths","setWavePaths","callback","timeout","requestRef","useRef","animate","setTimeout","current","requestAnimationFrame","useEffect","cancelAnimationFrame","clearInterval","useAnimationFrame","prevWaves","newPaths","paths","slice","lastPath","nextPath","push","updatePaths","nextStep","Object","assign","viewBox","version","map","className","stroke","d","Home","to","React","Component","divStyle","color","About","style","App","exact","path","element","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8d2e41c0.chunk.js","sourcesContent":["// Generates the string path defining the shape of the <path> element\nexport const pathToString = (pathData, index) => {\n    const { spaceBetweenLines, waveInterval, waveHeights } = pathData;\n    const spacer = spaceBetweenLines * index;\n    return `M${waveInterval[0]},${spacer} Q${waveInterval[1]},${waveHeights[0] +\n      spacer} ${waveInterval[2]},${spacer} T${waveInterval[3]},${waveHeights[1] +\n      spacer}`;\n};\n\n// here we get random values which we'll use to generate the first path\nexport const getRandomWave = svgWidth => {\n    const wave = {};\n    wave.spaceBetweenLines = 6; // this might change based on page height?\n    wave.waveInterval = getWaveIntervals(svgWidth); // we pass in the svg width for proportions!\n    wave.waveHeights = []; // two random values.\n    wave.waveHeights[0] = getWaveHeight(svgWidth);\n    wave.waveHeights[1] = getWaveHeight(svgWidth);\n    return wave;\n};\n\n// This is a helper function for `getRandomWave`\n// as I recall, basically each is like, a variable location for each peak\nconst getWaveIntervals = svgWidth => {\n    const waves = [];\n    for (let i = 0; i < 4; i++) {\n      waves[i] = getOneWaveInterval(svgWidth, i);\n    }\n    return waves;\n};\n\n//Wave interval makers!\nconst getOneWaveInterval = (svgWidth, waveIntervalIndex) => {\n    switch (waveIntervalIndex) {\n      case 0:\n        return Math.round(Math.random() * (svgWidth / 5) * -1);\n        break;\n      case 1:\n        return Math.round(Math.random() * (svgWidth / 2));\n        break;\n      case 2:\n        return Math.round(Math.random() * (svgWidth / 2) + svgWidth / 2);\n        break;\n      case 3:\n        return Math.round((Math.random() + 2) * svgWidth);\n        break;\n      default:\n        console.log(\"That's not a valid wave interval...\");\n    }\n  };\n\nconst getWaveHeight = svgWidth => {\n    return Math.round((Math.random() * svgWidth) / 2 - svgWidth / 10);\n};\n\nexport const getNextStep = ({ wave, targetWave, svgWidth, setTargetWave }) => {\n    let waveInterval = [0, 0, 0, 0];\n    let waveHeights = [0, 0];\n    let spaceBetweenLines = 8;\n  \n    for (let i = 0; i < waveInterval.length; i++) {\n      if (wave.waveInterval[i] > targetWave.waveInterval[i]) {\n        waveInterval[i] = wave.waveInterval[i] - 1;\n      } else if (wave.waveInterval[i] < targetWave.waveInterval[i]) {\n        waveInterval[i] = wave.waveInterval[i] + 1;\n      } else {\n        targetWave.waveInterval[i] = getOneWaveInterval(svgWidth, i);\n        setTargetWave(targetWave);\n        waveInterval[i] = wave.waveInterval[i];\n      }\n    }\n  \n    for (let j = 0; j < waveHeights.length; j++) {\n      if (wave.waveHeights[j] > targetWave.waveHeights[j]) {\n        waveHeights[j] = wave.waveHeights[j] - 1;\n      } else if (wave.waveHeights[j] < targetWave.waveHeights[j]) {\n        waveHeights[j] = wave.waveHeights[j] + 1;\n      } else {\n        targetWave.waveHeights[j] = getWaveHeight(svgWidth);\n        setTargetWave(targetWave);\n        waveHeights[j] = wave.waveHeights[j];\n      }\n    }\n    const newWave = { spaceBetweenLines, waveHeights, waveInterval };\n    return newWave;\n  };\n\n// Can't say I remember how this works.\n// Like...we're basically snipping the oldest path off and adding another one\n// I *think* this might sort of shuffle the paths FORWARD. \nexport const updatePaths = (paths, targetWave, svgWidth, setTargetWave) => {\n    const newPaths = paths.slice(1);\n    const lastPath = paths[paths.length - 1];\n    // Appallingly unclear code. The paths array is one shorter than usual because THIS one hasn't been pushed on yet\n    const nextPath = getNextStep({wave: lastPath, targetWave, svgWidth, setTargetWave});\n    newPaths.push(nextPath);\n    return newPaths;\n};","import React, { useState, useEffect } from 'react';\nimport { getNextStep, getRandomWave, pathToString, updatePaths } from '../utils'\nimport { useAnimationFrame } from '../hooks';\n\nexport const Lines = () => {\n    // this keeps track of the plotted paths for each line in the illustration.\n    // the entire array should be updated every frame to be slightly different.\n    const numberOfLines = 40;\n    const svgWidth = 300;\n    const [wavePaths, setWavePaths] = useState([]);\n    const [targetWave, setTargetWave] = useState(getRandomWave(svgWidth));\n\n    // so we'll accept delta time inside of the hook, and prevCount...\n    // but we're passing in the state setter.\n    useAnimationFrame(() => {\n        if (targetWave) {\n            setWavePaths(prevWaves => {\n                let newPaths = updatePaths(prevWaves, targetWave, svgWidth, setTargetWave);\n                return newPaths;\n            });\n        }\n    })\n\n    // wave and targetWave are the two different states that the animation is morphing between\n    // I have a nasty feeling that this is actually just the same logic as `updatePaths` \n    useEffect(() => {\n        let newPaths = [];\n        let wave = getRandomWave(svgWidth); // the current, frontmost wave\n        // generate the first batch of waves.\n        for (let i = 0; i < numberOfLines; i++) {\n            let nextStep = Object.assign({}, getNextStep({ wave, targetWave, svgWidth, setTargetWave }));\n            wave = nextStep;\n            newPaths.push(nextStep);\n        }\n        console.log(\"new paths: \", newPaths);\n        setWavePaths(newPaths);\n    }, []);\n    \n\n    return (\n        <svg\n            viewBox=\"0 20 200 200\"\n            version=\"1.1\"\n        >\n            <title>a flowing water model</title>\n            <desc>a bunch of lines</desc>\n            {\n                wavePaths.map((wave, index) => {\n                    return <path className=\"line\" stroke=\"#f2f2f2\" d={pathToString(wave, index)}/>\n                })\n            }\n        </svg>\n    )\n}","import { useEffect, useRef } from 'react';\n\nexport const useAnimationFrame = callback => {\n    // Use useRef for mutable variables that we want to persist\n    // without triggering a re-render on their change\n    const requestRef = useRef();\n    // ...do we care about the previous time ref...?\n    \n    // okay so time is the default value going into this call I guess\n    // we don't actually really care about the time.\n    // we care about the previous state of the wavePaths array.\n    const framesPerSecond = 35;\n    let timeout;\n    const animate = () => {\n        timeout = setTimeout(function() {\n            callback();\n            requestRef.current = requestAnimationFrame(animate);\n        }, 1000/framesPerSecond);\n    }\n    \n    useEffect(() => {\n        requestRef.current = requestAnimationFrame(animate);\n        return () => { \n            cancelAnimationFrame(requestRef.current); \n            clearInterval(timeout)\n        };\n    }, []); // Make sure the effect runs only once\n  }","import '../App.css';\nimport React from 'react';\nimport { Link } from 'react-router-dom';\nimport { Lines } from '../components/Lines'\n\nclass Home extends React.Component {\n    render() {\n        return (\n            <div className=\"home-wrapper\">\n                <Lines />\n                <div className=\"title-block\">\n                    <div className=\"text-block\">\n                        <p>Hi, I'm Mill</p>\n                    </div>\n                    <div className=\"button-wrapper\">\n                    <Link className=\"button\" to=\"/projects\">projects</Link>\n                    <Link className=\"button\" to=\"/about\">about</Link>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n}\n\nexport default Home;","import React from 'react';\n\nconst divStyle = {\n    color:'blue'\n};\n\nclass About extends React.Component {\n    \n    render() {\n        return (\n            <div style={divStyle}>\n                <h2>About Page</h2>\n                <p>Read all about it</p>\n            </div>\n        )\n    }\n}\n\n\n\nexport default About;","import './App.css';\nimport { Link, Routes, Route } from \"react-router-dom\"\nimport Home from './Pages/Home';\nimport About from './Pages/About';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Routes>\n        <Route exact path=\"/\" element={<Home />}/>\n        <Route path=\"/about\" element={<About />}/>\n      </Routes>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { HashRouter } from 'react-router-dom';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <HashRouter>\n      <App />\n    </HashRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}